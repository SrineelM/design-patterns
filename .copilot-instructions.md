# Design Patterns Project - GitHub Copilot Instructions

## Project Context

This is a comprehensive implementation of all 23 Gang of Four design patterns using Java 17 and Spring Boot 3.2.x. The project demonstrates best practices, modern Java features, and Spring Framework integration.

## Code Style Guidelines

### Java Conventions
- Use Java 17 features: records, sealed classes, pattern matching, switch expressions
- Follow standard Java naming conventions (camelCase for methods/variables, PascalCase for classes)
- Use `var` for local variables when type is obvious
- Prefer immutability: use `final` fields, records, and unmodifiable collections
- Maximum line length: 120 characters
- Indent: 4 spaces (no tabs)

### Documentation Standards
- **Every public class** must have comprehensive JavaDoc
- **Every public method** must have JavaDoc with `@param`, `@return`, `@throws`
- Include usage examples in JavaDoc with `<pre>` tags
- Add package-info.java for every package explaining its purpose
- Use `@author`, `@version`, `@since` tags
- Explain design decisions and trade-offs in comments

### Design Pattern Annotations
Always annotate pattern implementations with:
```java
@DesignPattern(
    name = "Pattern Name",
    category = "Creational|Structural|Behavioral",
    description = "Brief description of what this implements"
)
```

## Module Structure

### Multi-Module Organization
- **common/**: Shared interfaces, annotations, utilities
- **creational-patterns/**: 5 creational patterns
- **structural-patterns/**: 7 structural patterns
- **behavioral-patterns/**: 11 behavioral patterns

### Package Naming
- Base package: `com.example.patterns`
- Pattern packages: `com.example.patterns.{category}.{patternname}`
- Example: `com.example.patterns.creational.singleton`

## Spring Integration Guidelines

### Bean Configuration
- Use `@Component`, `@Service`, `@Repository` for automatic discovery
- Use `@Configuration` and `@Bean` for explicit bean creation
- Demonstrate `@Qualifier` for strategy pattern implementations
- Show `@Profile` for environment-specific beans
- Use `@Scope` to demonstrate singleton vs prototype

### Event-Driven Patterns
- Use `ApplicationEventPublisher` for observer pattern
- Use `@EventListener` for event handling
- Use `@Async` for asynchronous processing
- Use `@TransactionalEventListener` for transactional events

### AOP for Cross-Cutting Concerns
- Use `@Aspect` for decorator and proxy patterns
- Use `@Around`, `@Before`, `@After` for advice
- Use `@Cacheable` for caching proxy
- Use `@Transactional` for transaction management

## Testing Guidelines

### Test Structure
- Place tests in `src/test/java` mirroring source structure
- Use `@DisplayName` for readable test names
- Organize related tests with `@Nested` classes
- Use `@ParameterizedTest` for multiple input scenarios

### Naming Conventions
Test methods should follow: `shouldDoSomething_whenCondition()` or `shouldDoSomething_givenCondition()`

Examples:
- `shouldReturnSameInstance_whenCalledMultipleTimes()`
- `shouldThrowException_whenInputIsNull()`
- `shouldProcessPayment_successfully()`

### Assertion Style
Always use AssertJ for fluent assertions:
```java
assertThat(result).isNotNull();
assertThat(result.getValue()).isEqualTo(expected);
assertThat(list).hasSize(3).contains("value");
assertThatThrownBy(() -> method()).isInstanceOf(Exception.class);
```

### Mocking Guidelines
- Use `@Mock` for mock objects
- Use `@InjectMocks` for objects under test
- Use `@ExtendWith(MockitoExtension.class)` for JUnit 5
- Use `when().thenReturn()` for stubbing
- Use `verify()` to check interactions
- Prefer real objects over mocks when simple

### Coverage Goals
- Aim for >80% line coverage per pattern
- Test both happy paths and error scenarios
- Test edge cases and boundary conditions
- Test thread safety where relevant

## Pattern-Specific Guidelines

### Creational Patterns
- **Singleton**: Use enum for thread-safety (best practice)
- **Factory Method**: Use switch expressions for factory selection
- **Abstract Factory**: Show family of related objects
- **Builder**: Demonstrate both Lombok @Builder and custom builders for records
- **Prototype**: Implement deep copy correctly, show registry pattern

### Structural Patterns
- **Adapter**: Use MapStruct for complex bean mapping
- **Bridge**: Clearly separate abstraction from implementation
- **Composite**: Implement tree structures with sealed hierarchies
- **Decorator**: Show both traditional wrapping and Spring AOP
- **Facade**: Demonstrate simplification of complex subsystems
- **Flyweight**: Show memory efficiency through sharing
- **Proxy**: Demonstrate lazy loading, caching, access control

### Behavioral Patterns
- **Chain of Responsibility**: Show request passing through chain
- **Command**: Implement undo/redo functionality
- **Iterator**: Use Java Iterator interface, show custom implementations
- **Mediator**: Use Spring ApplicationEventPublisher
- **Memento**: Use records for immutable state snapshots
- **Observer**: Integrate with Spring events (@EventListener)
- **State**: Provide BOTH vanilla Java and Spring State Machine versions
- **Strategy**: Use Spring @Qualifier and Map injection for selection
- **Template Method**: Use abstract classes with final template methods
- **Visitor**: Leverage Java 17 pattern matching
- **Interpreter**: Build expression trees with sealed hierarchies

## Common Patterns to Implement

### Error Handling
- Always validate inputs
- Throw meaningful exceptions with descriptive messages
- Use custom exceptions extending `PatternException`
- Document exceptions in JavaDoc with `@throws`

### Resource Management
- Use try-with-resources for closeable resources
- Close streams and connections properly
- Avoid resource leaks in prototypes and flyweights

### Thread Safety
- Mark thread-safe classes in JavaDoc
- Use appropriate synchronization when needed
- Prefer immutability over synchronization
- Use concurrent collections when appropriate

## Code Generation Preferences

### When Creating New Classes
1. Start with comprehensive JavaDoc explaining purpose
2. Add `@DesignPattern` annotation if it's a pattern implementation
3. Include usage examples in JavaDoc
4. Implement all necessary methods
5. Add proper `toString()`, `equals()`, `hashCode()` where needed
6. Consider using records for simple data carriers

### When Creating Tests
1. Start with `@DisplayName` on class
2. Group related tests with `@Nested` classes
3. Use descriptive `@DisplayName` for each test
4. Follow Arrange-Act-Assert pattern
5. Test one thing per test method
6. Include both positive and negative test cases

### When Creating Spring Components
1. Choose appropriate stereotype annotation
2. Use constructor injection (preferred) over field injection
3. Document bean lifecycle considerations
4. Show how pattern integrates with Spring features
5. Provide configuration examples

## Lombok Usage

### When to Use Lombok
- `@Builder` for complex object construction
- `@Getter`/@Setter` for simple POJOs
- `@RequiredArgsConstructor` for constructor injection
- `@Slf4j` for logging
- `@ToString`, `@EqualsAndHashCode` for data classes

### When NOT to Use Lombok
- Use records instead of `@Data` for immutable data carriers
- Don't use `@Setter` with records (they're immutable)
- Avoid `@AllArgsConstructor` in favor of builder
- Don't use with complex inheritance hierarchies

## Build and Dependencies

### Gradle Configuration
- All versions managed in root build.gradle
- Use Spring Boot BOM for dependency management
- No bootJar for library modules (common, patterns)
- Keep dependencies minimal and purposeful

### Module Dependencies
- Patterns modules depend on common module
- No circular dependencies between modules
- Keep modules independent where possible

## Git Commit Messages

Follow conventional commits:
- `feat: Add Observer pattern with Spring events`
- `test: Add unit tests for Singleton pattern`
- `docs: Update README with pattern catalog`
- `fix: Correct deep copy in Prototype pattern`
- `refactor: Simplify Factory Method implementation`

## Documentation Hierarchy

1. **README.md** (root): Overview, quick start, pattern catalog
2. **package-info.java**: Package-level documentation
3. **Class JavaDoc**: Detailed class documentation
4. **Method JavaDoc**: Method-specific documentation
5. **Inline comments**: Complex algorithm explanations

## Performance Considerations

- Use flyweight for memory efficiency with large number of objects
- Use lazy initialization in proxy pattern
- Cache results in decorator pattern where appropriate
- Consider object pooling for expensive objects
- Profile before optimizing

## Security Considerations

- Validate all inputs (prevent injection attacks)
- Don't expose internal state unnecessarily
- Use defensive copying in prototypes
- Control access through proxy pattern
- Sanitize data in interpreters

## Remember

- **Every pattern should be production-ready**, not just a toy example
- **Real-world use cases** are more valuable than academic examples
- **Beginner-friendly documentation** is crucial - explain concepts clearly
- **Spring integration** should feel natural, not forced
- **Tests are documentation** - they show how to use the pattern
- **Modern Java features** should enhance, not complicate the patterns

## Questions to Ask Yourself

Before implementing or modifying code:
1. Does this follow the pattern's intent?
2. Is this beginner-friendly and well-documented?
3. Does this demonstrate best practices?
4. Can Spring enhance this without overcomplicating it?
5. Are there sufficient tests?
6. Is this production-ready code?

---

**Goal**: Create a reference implementation that developers can learn from and use as a template for their own projects.
